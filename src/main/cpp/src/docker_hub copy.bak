

use bytes::{Bytes};

use anyhow::bail;

use serde::Deserialize;
use serde_json;



pub struct DockerHub{
    token:String,
    auth_base_url:String,
    registry_base_url:String,
    container_name:String,
    container_version:String,
    container_current_platform_digest:String,
    container_layers:Vec<(String,String)>,
    container_arch:Option<String>,
}

#[derive(Deserialize, Debug)]
struct JManifestsPlatform{
    architecture:String,
    os:String,
    variant:Option<String>,
}

#[derive(Deserialize, Debug)]
struct JManifestsRow {
    digest: String,
//    mediaType: String,
    platform: JManifestsPlatform,
//    size:u32,
}

#[derive(Deserialize, Debug)]
struct JManifests{
    manifests:Option<Vec<JManifestsRow>>,
    layers:Option<Vec<JManifestLayersRow>>,

}
#[derive(Deserialize, Debug)]
struct JManifestLayersRow{
#[serde(rename = "mediaType")]
    media_type: String,
//    size:u32,
    digest:String,
}


#[derive(Deserialize, Debug)]
struct JManifest{
//    schemaVersion: i32,
    layers:Vec<JManifestLayersRow>,
}



impl DockerHub{

    pub fn new(container_name:String,container_version:String,arch: Option<String>) -> Self{
        DockerHub{
            token:String::new(),
            auth_base_url:String::from("https://auth.docker.io"),
            registry_base_url:String::from("https://registry-1.docker.io"),
            container_name:container_name,
            container_version:container_version,
            container_current_platform_digest:String::new(),
            container_layers:Vec::new(),
            container_arch:arch,
        }
    }

    async fn prepare_reqwest_and_send(&self,url:&str)->anyhow::Result<reqwest::Response>{
        let mut client = reqwest::Client::new()
        .get(url)
        .header("Accept","application/vnd.docker.distribution.manifest.v2+json")
        .header("Accept","application/vnd.docker.distribution.manifest.list.v2+json");

        if !self.token.is_empty(){
            client=client.header("Authorization", format!("Bearer {}",self.token) );
        }

        let resp=client
        .send()
        .await?;

        return Ok(resp);
    }

    async fn get_json_response_using_auth_if_possible(&self,url:&str) -> anyhow::Result<serde_json::Value>{
            let resp=self
            .prepare_reqwest_and_send(url)
            .await?
            .text()
            .await?;
            let jdata: serde_json::Value = serde_json::from_str(resp.as_str())?;
            Ok(jdata)
    }

    async fn get_binary_response_using_auth_if_possible(&self,url:&str) -> anyhow::Result<Bytes>{
        let resp=self
        .prepare_reqwest_and_send(url)
        .await?
        .bytes()
        .await?;
        Ok(resp)
    }

    async fn get_token(&mut self)-> anyhow::Result<()>{
        let j = self.get_json_response_using_auth_if_possible(format!("{}/token?service=registry.docker.io&scope=repository:{}:{}:pull",self.auth_base_url,self.container_name,self.container_version).as_str()).await?;
        let j_token=j.get("token");
        if j_token.is_none(){bail!("token not found in response")}
        let j_token_s=j_token.unwrap().as_str();
        if j_token_s.is_none(){bail!("cant convert token to string")}        
        self.token=j_token_s.unwrap().to_string();
        Ok(())
    }

    async fn get_manifest_digest_for_current_arch(&mut self)-> anyhow::Result<String>{
        if self.token.is_empty(){self.get_token().await?}
        let url=format!("{}/v2/{}/manifests/{}",self.registry_base_url,self.container_name,self.container_version);
        println!("dbg url = {}",url);
        let j_base_manifests = self.get_json_response_using_auth_if_possible(url.as_str()).await?;  

        println!("debug response={}",j_base_manifests.clone());
        let response:JManifests = serde_json::from_value(j_base_manifests)?;
        for row in response.manifests{
            let  need_arch:String;
            let mut need_sub_arch:Option<String>=None;
            
            #[cfg(target_arch = "x86")]
            let local_arch="x86".to_string(); // ???

            #[cfg(target_arch = "x86_64")]
            let local_arch="amd64".to_string();

            #[cfg(target_arch = "arm")]
            let local_arch="arm".to_string();

            #[cfg(target_arch = "aarch64")]
            let local_arch="arm64".to_string();                    


            if let Some(arch)=&self.container_arch{
                let exp_arch:Vec<String>=arch.split("/").map(|f|f.to_string()).collect();
                match exp_arch.len() {
                    1=>{ need_arch=exp_arch[0].to_string(); },
                    2=>{ need_arch=exp_arch[0].to_string(); need_sub_arch=Some( exp_arch[1].to_string() ); },
                    _=>{bail!("wrong arch. should be arch/subarch or arch")},
                }
            }else{
                need_arch=local_arch;
            }

            if row.platform.os.eq("linux") && row.platform.architecture.eq(need_arch.as_str()) {
                if let Some(sub_arch)=need_sub_arch{
                    if let Some(variant_s)=row.platform.variant{
                        if variant_s.eq(sub_arch.as_str()){
                            self.container_current_platform_digest=row.digest.clone();
                            return Ok(row.digest);     
                        }
                    }
                }else{
                    self.container_current_platform_digest=row.digest.clone();
                    return Ok(row.digest);    
                }
            }
        }
        bail!("can't find supported manifest")
    }

    pub async fn get_layers_urls(&mut self,manifest:Option<String>)-> anyhow::Result<Vec<(String,String)>>{
        let current_manifest;
        if manifest.is_none(){
            if self.container_current_platform_digest.is_empty(){self.get_manifest_digest_for_current_arch().await?;}
            current_manifest=self.container_current_platform_digest.clone();
        }else{
            current_manifest=manifest.unwrap();
        }

        let j_base_manifest = self.get_json_response_using_auth_if_possible(format!("{}/v2/{}/manifests/{}",self.registry_base_url,self.container_name,current_manifest).as_str()).await?;        
        let response:JManifest = serde_json::from_value(j_base_manifest)?;
        let mut ret_vector:Vec<(String,String)>=vec![];
        for row in response.layers{
            //need real filename (format)
            let url=format!("{}/v2/{}/blobs/{}",self.registry_base_url,self.container_name,row.digest ).to_string();
            ret_vector.push(  (url,row.media_type.clone())  );
        }
        self.container_layers=ret_vector.clone();
        return Ok(ret_vector);
    }

    //execute unpacking func 
    pub async fn download_blob(&mut self, layer_url:String) -> anyhow::Result<Bytes>{
        let layer:bytes::Bytes=self.get_binary_response_using_auth_if_possible(layer_url.as_str()).await?;
        Ok(layer)
    }

    /* 
    pub async fn download_blobs<F,Fut>(&mut self, f:F  ) -> anyhow::Result<()>
    where 
    F: Fn(Bytes,String)->Fut,
    Fut: Future<Output = anyhow::Result<()> >,
     { 
            let layers=self.get_layers_urls(None).await?;
            for (layer_url,layer_format) in layers{
                let layer:bytes::Bytes=self.get_binary_response_using_auth_if_possible(layer_url.as_str()).await?;
                f(layer,layer_format).await?;
            }
            Ok(())
    }
    */


}
/*

#[cfg(test)]
mod tests {
    use crate::docker_hub::DockerHub;
//    #[test]
    #[tokio::test]
    async fn it_works() {
        let mut app = DockerHub::new("library/ubuntu".to_string(),"latest".to_string());
        let layers=app.get_layers_urls(None).await.unwrap();
        println!("layers={:?}",layers);
    }
}
 */



/*
adb shell am start -a android.settings.SETTINGS

To bring up developer settings (in Gingerbread at least):

adb shell am start -a com.android.settings.APPLICATION_DEVELOPMENT_SETTINGS


*/


/*
ref="${1:-library/ubuntu:latest}"
sha="${ref#*@}"
if [ "$sha" = "$ref" ]; then
  sha=""
fi
wosha="${ref%%@*}"
repo="${wosha%:*}"
tag="${wosha##*:}"
if [ "$tag" = "$wosha" ]; then
  tag="latest"
fi
api="application/vnd.docker.distribution.manifest.v2+json"
apil="application/vnd.docker.distribution.manifest.list.v2+json"
token=$(curl -s "https://auth.docker.io/token?service=registry.docker.io&scope=repository:${repo}:pull" \
        | jq -r '.token')
curl --verbose -H "Accept: ${api}" -H "Accept: ${apil}" \
     -H "Authorization: Bearer $token" \
     -s "https://registry-1.docker.io/v2/${repo}/blobs/sha256:c38006c9acc492149d706593acba951110798e57a7ad05103ae7a2d5969c14b6"

#     -s "https://registry-1.docker.io/v2/${repo}/manifests/sha256:ea8f467d512068a1e52494d5b2d959a9307a35682633d0b5d481e79c914c627f" | jq .
#     -s "https://registry-1.docker.io/v2/${repo}/manifests/${sha:-$tag}" | jq .
*/